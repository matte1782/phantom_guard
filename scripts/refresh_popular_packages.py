#!/usr/bin/env python3
"""
Script to refresh the popular packages database.

Run monthly to update the lists:
    python scripts/refresh_popular_packages.py

Sources:
- PyPI: hugovk/top-pypi-packages (30-day downloads)
- npm: npms.io API
- crates.io: Official API (sorted by downloads)
"""

from __future__ import annotations

import time
from datetime import UTC, datetime
from pathlib import Path

import httpx

OUTPUT_PATH = Path("src/phantom_guard/data/popular_packages.py")


def fetch_pypi_top_packages(limit: int = 1000) -> list[str]:
    """
    Fetch top PyPI packages from hugovk's dataset.

    Source: https://hugovk.github.io/top-pypi-packages/
    """
    url = "https://hugovk.github.io/top-pypi-packages/top-pypi-packages-30-days.min.json"

    print(f"Fetching PyPI packages from {url}...")
    response = httpx.get(url, timeout=30.0)
    response.raise_for_status()

    data = response.json()
    packages = [row["project"].lower() for row in data["rows"][:limit]]

    print(f"  Fetched {len(packages)} PyPI packages")
    return packages


def fetch_npm_top_packages(limit: int = 1000) -> list[str]:
    """
    Fetch top npm packages using npms.io API.

    Uses quality + popularity scoring.
    """
    packages: list[str] = []
    offset = 0
    size = 250  # Max per request

    print("Fetching npm packages from npms.io...")

    while len(packages) < limit:
        url = f"https://api.npms.io/v2/search?q=not:deprecated&size={size}&from={offset}"

        try:
            response = httpx.get(url, timeout=30.0)
            response.raise_for_status()

            data = response.json()
            results = data.get("results", [])

            if not results:
                break

            for item in results:
                pkg_name = item.get("package", {}).get("name", "")
                if pkg_name and pkg_name not in packages:
                    packages.append(pkg_name)

            offset += size
            print(f"  npm: {len(packages)}/{limit}...", end="\r")
            time.sleep(0.5)  # Rate limiting

        except Exception as e:
            print(f"\n  npm fetch error at offset {offset}: {e}")
            break

    packages = packages[:limit]
    print(f"  Fetched {len(packages)} npm packages    ")
    return packages


def fetch_crates_top_packages(limit: int = 1000) -> list[str]:
    """
    Fetch top crates.io packages by downloads.

    Uses official crates.io API.
    """
    packages: list[str] = []
    page = 1
    per_page = 100

    print("Fetching crates.io packages...")

    while len(packages) < limit:
        url = f"https://crates.io/api/v1/crates?page={page}&per_page={per_page}&sort=downloads"
        headers = {"User-Agent": "phantom-guard/0.1.0 (https://github.com/phantom-guard)"}

        try:
            response = httpx.get(url, headers=headers, timeout=30.0)
            response.raise_for_status()

            data = response.json()
            crates = [c["name"].lower() for c in data["crates"]]

            if not crates:
                break

            packages.extend(crates)
            page += 1
            print(f"  crates: {len(packages)}/{limit}...", end="\r")
            time.sleep(0.5)  # Rate limiting

        except Exception as e:
            print(f"\n  crates.io fetch error at page {page}: {e}")
            break

    packages = packages[:limit]
    print(f"  Fetched {len(packages)} crates.io packages    ")
    return packages


def format_set(packages: list[str], name: str) -> str:
    """Format a list of packages as a frozenset declaration."""
    lines = [f"{name}: frozenset[str] = frozenset(("]
    for i in range(0, len(packages), 8):
        chunk = packages[i : i + 8]
        quoted = ", ".join(f'"{p}"' for p in chunk)
        lines.append(f"    {quoted},")
    lines.append("))")
    return "\n".join(lines)


def generate_module(
    pypi: list[str],
    npm: list[str],
    crates: list[str],
) -> str:
    """Generate the Python module with frozen sets."""
    date = datetime.now(UTC).strftime("%Y-%m-%d")

    module = f'''"""
Popular packages database for false positive prevention.

IMPLEMENTS: S006 (typosquat detection enhancement)
EC: EC043, EC046

Contains top 1000 packages per registry to prevent false positives
on legitimate popular packages.

Auto-generated by: scripts/refresh_popular_packages.py
Last updated: {date}
Package counts: PyPI={len(pypi)}, npm={len(npm)}, crates={len(crates)}
"""

from __future__ import annotations

# PyPI Top {len(pypi)} (by monthly downloads)
{format_set(pypi, "PYPI_POPULAR")}

# npm Top {len(npm)} (by dependents/downloads)
{format_set(npm, "NPM_POPULAR")}

# crates.io Top {len(crates)} (by downloads)
{format_set(crates, "CRATES_POPULAR")}

# Registry lookup
POPULAR_BY_REGISTRY: dict[str, frozenset[str]] = {{
    "pypi": PYPI_POPULAR,
    "npm": NPM_POPULAR,
    "crates": CRATES_POPULAR,
}}


def is_popular(name: str, registry: str = "pypi") -> bool:
    """
    Check if a package is in the popular packages list.

    Args:
        name: Package name to check
        registry: Registry to check against

    Returns:
        True if package is in the top 1000 for the registry
    """
    popular = POPULAR_BY_REGISTRY.get(registry.lower(), PYPI_POPULAR)
    return name.lower() in popular


def get_popular_packages(registry: str = "pypi") -> frozenset[str]:
    """
    Get the set of popular packages for a registry.

    Args:
        registry: Registry name (pypi, npm, crates)

    Returns:
        Frozen set of popular package names
    """
    return POPULAR_BY_REGISTRY.get(registry.lower(), PYPI_POPULAR)
'''

    return module


def main() -> None:
    """Fetch all packages and generate module."""
    print("=" * 60)
    print("  Phantom Guard - Popular Packages Refresh")
    print("=" * 60)
    print()

    pypi = fetch_pypi_top_packages(1000)
    npm = fetch_npm_top_packages(1000)
    crates = fetch_crates_top_packages(1000)

    print()
    print("Generating module...")

    module_content = generate_module(pypi, npm, crates)

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUTPUT_PATH.write_text(module_content)

    print(f"Written to {OUTPUT_PATH}")
    print()
    print("=" * 60)
    print("  Summary")
    print("=" * 60)
    print(f"  PyPI:     {len(pypi):>4} packages")
    print(f"  npm:      {len(npm):>4} packages")
    print(f"  crates:   {len(crates):>4} packages")
    print(f"  Total:    {len(pypi) + len(npm) + len(crates):>4} packages")
    print("=" * 60)


if __name__ == "__main__":
    main()
